# O modelo OSI: redes complexas simplificadas



A Internet é extremamente complexa. Ele contém bilhões de dispositivos, cada um conectado à sua maneira. Navegar até lá sem um mapa seria impossível: o modelo OSI é apenas esse mapa. Depois de apresentar as oportunidades que as TIC têm a oferecer, é hora de começar com o material técnico. Com este artigo, você está oficialmente começando sua jornada em direção à *certificação Cisco Certified Networking Associate* , então parabéns! Agora, vamos apresentar exatamente o que é o modelo OSI e por que ele é necessário.

## Onde está a Internet?

Você já se perguntou *onde está a Internet?* Quero dizer, você pode viajar ao redor do mundo, encontrar um ponto de acesso Wi-Fi gratuito, conectar-se a ele e bum - você está dentro. É como uma enorme nuvem mágica flutuando ao nosso redor, em todos os lugares. É como se estivesse no ar. Assim, depois de se conectar ao hotspot que está pronto para ir, você pode navegar no seu site favorito e, em menos de um segundo, estará na tela. Mesmo se você for completamente novo em TIC, podemos entender algo sobre isso. Pense nisso, você precisa estar conectado para visitar aquele site. Pode parecer óbvio, e provavelmente é, mas como estamos acostumados a estar sempre conectados, podemos esquecer que: **você precisa estar conectado** para acessar um determinado site.



![Onde está a internet - sem noção](https://www.ictshore.com/wp-content/uploads/2016/09/1005-01-Where_is_the_internet.png)Você se conecta à Internet e, de alguma forma, pode acessar seu site favorito.

Neste ponto, podemos afirmar que o site não está realmente no seu computador, caso contrário, você não precisaria de acesso à Internet. Em vez disso, ele está em algum lugar da Internet e você deve se conectar a ele para obter seu conteúdo. Em seguida, você clica em um link e aciona o mesmo processo de busca na Internet. Estamos usando um site como exemplo, mas isso poderia ser feito com um fluxo de vídeo em tempo real, uma chamada do Skype, jogos online e assim por diante. Mas vamos nos concentrar no site: sabemos que está dentro da Internet, mas a Internet é enorme. Precisamos saber onde está para obtê-lo. Se não soubermos onde procurar, seria mais fácil procurar uma agulha no palheiro. Portanto, temos que saber o caminho para chegar ao site. Pense por um minuto, onde você se conectou? Sim, o ponto de acesso gratuito.Também pode ser o seu Wi-Fi doméstico ou uma conexão de internet móvel (como LTE, 4G ou 3G), mas o conceito por trás disso ainda é o mesmo: viagens de dados*pelo ar* do seu laptop para o ponto de acesso (ou antena móvel, o que for).

![Até o roteador](https://www.ictshore.com/wp-content/uploads/2016/09/1005-02-Up_to_the_Router.png)Você conecta seu laptop com uma conexão com fio ou sem fio a um roteador, como o que você tem em casa. O que há entre o seu roteador e o site ainda está faltando na imagem.

Agora conhecemos o primeiro dispositivo ao qual nos conectamos, mas esta é apenas uma etapa, a mais fácil. O que está por trás de sua rede doméstica, a “Internet real” ainda é desconhecida. A verdade é que, no fundo, o conceito é bastante semelhante ao da sua rede doméstica. Antes de prosseguirmos, você precisa entender o que é um **roteador** . Teremos muito tempo para colocar uma definição mais técnica em sua mente, mas por enquanto essa definição será mais do que suficiente.

> Um roteador é um dispositivo de rede intermediário com a função de encaminhar (rotear) dados entre outros dispositivos (até mesmo outros roteadores), com base em um esquema de endereçamento “geográfico”.

Em outras palavras, um roteador receberá algumas informações de um dispositivo (como seu laptop) destinado a outro dispositivo (e não ao próprio roteador). O roteador sabe, com base nas informações recebidas, *para onde enviar* essa informação. Pode ser que mande para outro roteador, que vai repetir o processo, e vai até chegar ao destino. Em teoria, é trivial, mas não é. Por exemplo, e se o esquema de endereçamento não for geograficamente consistente (alguns endereços que você acredita estar nos EUA estão na Europa), que é um caso comum? E se um roteador tiver dois caminhos para chegar ao mesmo destino? Como podemos evitar que a parte da informação entre em loop se ela continua voltando para o mesmo roteador continuamente? Estas são apenas algumas perguntas sobre*“Como funciona a Internet, exatamente?”* e todos eles têm uma resposta, caso contrário, a Internet não estaria funcionando agora.

*Uma nota simples antes de continuarmos, com geográfica não queremos dizer estritamente relacionada a uma área geográfica. Em vez disso, pense que as redes têm sua própria geografia, paralela à geografia do mundo real.*

Agora sabemos como é a Internet: **um conjunto de dispositivos intermediários que** entregam a solicitação do seu laptop para o site e, em seguida, o conteúdo do site para o seu laptop. Mas espere um segundo, qual é o site? Quer dizer, traduzimos a nuvem mágica em um conjunto de roteadores, é possível traduzir o site em algo tangível? Sim, ele é! Um site da Web nada mais é do que um serviço - um aplicativo - executado em um computador. Este computador será considerado um **servidor**já que seu principal objetivo é atender às solicitações de outros computadores. O aplicativo do site irá sentar e ouvir, esperando por uma solicitação. Cada vez que uma solicitação é recebida, ela é analisada e o conteúdo relacionado é enviado de volta. Um servidor pode hospedar muitos sites ao mesmo tempo e enquanto o aplicativo que escuta as solicitações e fornece respostas é o mesmo para a maioria dos sites (duas alternativas válidas são [Apache](https://translate.google.com/website?sl=en&tl=pt&nui=1&u=https://httpd.apache.org/) ou [Nginx](https://translate.google.com/website?sl=en&tl=pt&nui=1&u=https://nginx.org) ), o que realmente muda é *o conteúdo* fornecido na resposta.

![Caminho na Internet](https://www.ictshore.com/wp-content/uploads/2016/09/1005-03-Path_within_the_internet.png)A Internet é composta de dispositivos e servidores intermediários. A cada vez, o melhor caminho será escolhido para entregar as informações da melhor maneira.

Outra grande coisa a se considerar é que a Internet pode sobreviver a tudo. Terremotos, grandes cortes de energia, tudo. Isso ocorre porque ele é distribuído no mundo (os roteadores que compõem a Internet estão em todos os lugares) e não há um único ponto em que toda a Internet dependa. Claro, alguns dispositivos são mais importantes do que outros (seu roteador doméstico não pode competir com os dispositivos que fornecem conectividade para toda a região da Ásia-Pacífico, por exemplo), mas esses dispositivos são redundantes para que se um falhar, outro assumirá seu carga de trabalho. Mas a magnitude da Internet e sua capilaridade não são suficientes. A Internet é **em tempo real** . Com isso, quero dizer duas coisas. O primeiro é o mais simples de adivinhar: você pode obter o que precisa *instantaneamente*, em tempo real. A segunda coisa não é tão óbvia, mas é muito mais importante: *a Internet pode se adaptar automaticamente a mudanças e falhas* . Se você acha que os dispositivos da Internet raramente falham, pense novamente. A qualquer momento, haverá uma falha de dispositivo na Internet. A boa notícia é que outros dispositivos reconhecerão isso e agirão conseqüentemente, movendo o tráfego para outro caminho. É por isso que a Internet é tão **poderosa** e também pode ser bastante complexa. Para ajudar a simplificar tudo, a *pilha OSI* foi desenvolvida.

## Escondendo a complexidade com OSI

O título afirma isso claramente: O modelo OSI foi projetado para ocultar a complexidade das redes. Isso não é totalmente verdade, mas é o que parece. Antes de explicar o que é o modelo OSI, vamos apresentar as necessidades que o tornaram *necessário* .

Dê uma olhada na foto anterior, onde seu computador estava se comunicando com um servidor em algum lugar da Internet. Podemos ver 5 roteadores diretamente envolvidos no processo de encaminhamento de dados. Agora, o que são esses roteadores *eram pessoas*? Imagine que a informação está contida em uma caixa, e essas pessoas passam essa caixa entre si até que seja entregue no destino, como uma cadeia de suprimentos. Para selecionar quem será a próxima pessoa a passar a caixa, há uma etiqueta na caixa. Esse enorme rótulo contém uma instrução para cada pessoa na cadeia, escrita especificamente para ele. Assim que uma pessoa encontrar as instruções, cruze-as com um marcador e passe-as para a próxima pessoa, conforme aprendido nas instruções. Agora, a Internet é mundial, então nem todas as pessoas dessa rede falam a mesma língua. Portanto, cada instrução deve ser escrita em um idioma que você tenha certeza de que o destinatário será capaz de ler. E se uma pessoa da rede for substituída por outra que não fala a mesma língua? Você tem que reescrever todo o rótulo e, o mais importante,você - o primeiro nó - tem que saber todas as linguagens possíveis. Não é**complexo** ? Ou seja, você tem que cuidar de tudo e colocar um conjunto de instruções detalhadas para todos os demais. Para deixar ainda mais claro, vamos listar as principais falhas dessa abordagem.

- Você tem que saber o caminho que seus dados tomarão de *antemão*
- Você tem que conhecer *todos os idiomas* da Internet
- Caso um nó seja substituído por outro que não fale a mesma língua após o envio da sua caixa, *ele será perdido* porque o novo nó não conseguirá encaminhá-lo corretamente
- Se um nó falhar, não há instruções alternativas a serem seguidas, então *a caixa está perdida*

Esses são apenas alguns, os mais fáceis de entender para alguém que é relativamente novo em redes. O modelo OSI trata de todos esses problemas, permitindo escalabilidade e desempenho aprimorados. O modelo OSI é um conjunto de protocolos, mas o que é um protocolo em um ambiente de rede?

> Um protocolo é um conjunto de regras que definem como a comunicação entre dois dispositivos deve acontecer.

Tecnicamente, um protocolo é implementado com um **algoritmo** (processo de raciocínio em um dispositivo) e um conjunto de **mensagens** trocadas entre os dois dispositivos. As mensagens são os dados trocados entre os dispositivos, ao passo que o algoritmo é a aplicação que vai ouvir essas mensagens e entendê-las. Toda comunicação que ocorre na Internet é definida por um protocolo, e no caminho entre o seu computador e o site você deverá utilizar diversos protocolos. Felizmente, o seu computador e os dispositivos de rede fazem tudo isso por você. Dessa forma, você pode simplesmente digitar o URL do site (como [https://www.ictshore.com](https://www-ictshore-com.translate.goog/free-ccna-course/osi-model-introduction/?_x_tr_sl=en&_x_tr_tl=pt&_x_tr_hl=nl&_x_tr_pto=nui) ) e apreciar a vista.

Para esconder essa complexidade, resolvendo assim os problemas listados acima, *temos que usar protocolos* . Pense desta forma: você tem que enviar algo e colocá-lo em uma caixa, mas em vez de aplicar uma etiqueta definindo tudo sobre como deve ser entregue, você apenas escreve na etiqueta o destinatário pretendido. Então você fecha aquela caixa e coloca em outra caixa. Na caixa externa, você escreve o primeiro destinatário pretendido e, em seguida, envia para ele. Depois de recebê-lo, ele abre a caixa externa e olha para o rótulo da caixa interna, então ele pensa *“Ok, para falar com John eu devo dar para Mary!”* e coloque sua caixa em uma caixa externa mais recente destinada a Maria. Este processo continua até que a caixa chegue a John. Nesse ponto, John abre a caixa e lê seu conteúdo. Este processo é chamado de **encapsulamento**, e tem um grande benefício: você mantém as informações de acessibilidade sobre seu alvo e não se preocupa com o caminho que sua caixa tomará, dispositivos intermediários decidirão por você. Em outras palavras, você cria algo que parece um túnel, um canal de comunicação separado que passa pela Internet conectando seu computador ao site, *virtualmente* **diretamente** .

![Escondendo a Complexidade](https://www.ictshore.com/wp-content/uploads/2016/09/1005-05-Hiding_Complexity.png)Os protocolos são usados nas comunicações da Internet. Existem alguns protocolos (vermelho, verde) que definem como deve ocorrer a comunicação entre dois dispositivos conectados e, encapsulado neles, existe um outro protocolo (amarelo) que define a comunicação sobreposta entre dispositivos não conectados diretamente.

A imagem acima é um exemplo claro do que consiste o encapsulamento. Os protocolos, representados por um conjunto de regras ( *documento* ), definem como a comunicação deve ocorrer. Um protocolo define a comunicação entre o primeiro e o segundo roteador, enquanto outro protocolo define a comunicação entre o segundo e o terceiro roteador. Ainda outro protocolo define como a comunicação deve acontecer durante a passagem por esses roteadores. Em outras palavras, os protocolos vermelho e verde definem como **as caixas externas** devem ser feitas, enquanto o protocolo amarelo define como as **caixas internas** devem ser feitas. A imagem a seguir deixará isso ainda mais claro para você.

![Processo de encapsulamento](https://www.ictshore.com/wp-content/uploads/2016/09/1005-11-Encapsulation.png)O processo de encapsulamento coloca dados e solicitações em um conjunto de caixas aninhadas.

Seu laptop sabe que precisa chegar à ICTShore, então cria uma solicitação com “Get me the web page” e a coloca em uma caixa amarela destinada à ICTShore. Seu laptop sabe também que para chegar a qualquer coisa na Internet como falar com o Roteador 1, ele coloca a caixa **amarela** em uma caixa **vermelha** destinada ao Roteador 1. O Roteador 1 recebe essa caixa, abra-a e descubra que o conteúdo é para ICTShore. Ele não precisa checar o conteúdo da caixa amarela porque sabe que para chegar ao ICTShore ele tem que contatar o Roteador 2. Para falar com o Roteador 2, porém, ele precisa usar outro protocolo, o protocolo azul, então colocou a caixa amarela na **azul**caixa (a caixa amarela é sempre a mesma) e envia para o Roteador 2. Então, o Roteador 2 repete o processo e descobre que a caixa tem que ser encaminhada para o Roteador 3, falando com o protocolo **verde** . Ele faz exatamente isso e o Roteador 3 entende que a caixa é para o ICTShore, que é conectado ali mesmo e entrega no servidor usando o protocolo vermelho. O fato principal é que nem o seu laptop nem o ICTShore.com sabem quais são os protocolos usados na rede, *eles conhecem apenas o protocolo amarelo* e o **vermelho**protocolo (porque ambos conversam com seu roteador usando esse protocolo). Os protocolos no caminho podem mudar, mas eles não precisam conhecê-los. Isso torna tudo mais flexível, porque se um protocolo mudar em qualquer lugar da Internet, apenas os nós conectados saberão disso. No final, o servidor abrirá a solicitação, lerá e criará uma resposta.

Existem algumas regras muito específicas para definir como os protocolos devem interagir uns com os outros. Para eles, verifique a seção a seguir.

## Categorizando protocolos

Já definimos o que é um protocolo (só para lembrar, *é um conjunto de regras que definem como a comunicação entre dois dispositivos deve acontecer* ), mas depois introduzimos o encapsulamento e o fato de que os protocolos são colocados um no outro. Isso significa necessariamente que os protocolos se comunicam em algum nível: com base no receptor pretendido, um dispositivo intermediário selecionará o próximo roteador para o qual enviar a caixa. Portanto, ele deve usar o protocolo / encapsulamento correto (caixa externa) para se comunicar com esse roteador. Os protocolos podem começar a se fundir se não tivermos uma maneira de categorizá-los. Felizmente, é exatamente disso que trata o modelo OSI:

> O modelo OSI (ou pilha OSI) é uma maneira de categorizar protocolos em camadas com base em seu uso. Outras duas pilhas usadas para categorizar protocolos são o modelo TCP / IP e o modelo Híbrido (que mescla OSI com TCP / IP).

**OSI** significa **Open Systems Interconnection** , porque foi projetado pela **ISO (International Organization for Standards)** para aprimorar a criação de protocolos que permitem que máquinas de diferentes fornecedores conversem entre si. *Décadas atrás* , os sistemas de um fornecedor (como IBM ou Apple) não conseguiam se comunicar, porque cada um deles usava seu próprio sistema de comunicação. Felizmente, agora existe um modelo padronizado que permite que todos falem com todos os outros.

Para atingir seu objetivo de interconectar vários sistemas diferentes, o OSI define *sete camadas diferentes* de protocolos de uma forma muito precisa e estrita. A informação é passada apenas para **camadas contíguas** (o protocolo na camada seguinte na parte superior ou na parte inferior) e ele não pode “pular” algumas camadas. Dessa forma, se algo mudar em uma camada, apenas as duas camadas conectadas perceberão essa mudança.

![Benefícios das camadas](https://www.ictshore.com/wp-content/uploads/2016/09/1005-06-Benefits_of_layers.png)Se a pilha OSI fosse uma parede, alterar um tijolo em uma camada não afetaria as camadas que não estão anexadas a ele.

Não apenas *uma camada pode falar apenas com as que estão diretamente conectadas* , mas também “ **controla** ” a camada que está diretamente abaixo. Isso porque se um roteador recebe uma caixa para um dispositivo não conectado, ele tem que descobrir qual deve ser o próximo roteador e, a partir disso, usar a “caixa externa” (protocolo) apropriada para se comunicar com esse roteador. Talvez, com outro próximo roteador, um protocolo diferente seja necessário. Com isso, podemos entender que sua aplicação (sua navegação na web) está nas camadas superiores e o cabo que conecta dois roteadores está na parte inferior do modelo OSI. Então, você começa do topo quando envia algo e isso é **encapsulado cada vez que** seu conteúdo passa por uma camada. Finalmente, é colocado no *cabo*e quando chega ao destino é passado para as camadas superiores até que todas *as caixas externas sejam removidas* . Pode parecer um pouco abstrato no momento, mas assim que você entender o papel de cada camada, tudo ficará mais claro.

![Pilhas de protocolo](https://www.ictshore.com/wp-content/uploads/2016/09/1005-07-Protocol_Stock.png)Pilhas de protocolo: OSI, TCP / IP e híbrido.

Os protocolos são sempre os mesmos, esses três modelos são apenas três maneiras diferentes de categorizá-los. Como você pode ver, essas três pilhas diferentes são bastante semelhantes. Vamos começar a partir do OSI, levantando a pilha do fundo (começando pelo hardware e cabos).

1. **Física** - esta camada controla como os dados são colocados no cabo (frequências, sinais e todas as outras coisas que estão mais relacionadas à física e eletricidade do que ICT)
2. **Data Link** - define quantos dados podem ser colocados no cabo ao mesmo tempo, como deve ser formatado e também detecta se algo der errado durante a transmissão
3. **Rede** - define informações de endereçamento para nós não conectados diretamente, permitindo que você alcance um dispositivo remoto
4. **Transporte** - define informações de endereçamento para aplicativos e serviços, enquanto a camada de rede permite que você alcance um dispositivo remoto, o transporte permite que aplicativos em dispositivos remotos conversem entre si
5. **Sessão** - certifique-se de que a informação seja entregue corretamente entre aplicativos remotos (pode ser tratada por protocolos na camada de transporte sem a necessidade de um protocolo específico de sessão
6. **Apresentação** - defina informações sobre como compactar e apresentar seu conteúdo, usado principalmente para tráfego em tempo real, como fluxos de voz ou vídeo
7. **Aplicativo** - os dados de seu aplicativo, como a solicitação de uma página da web

Portanto, seu navegador ( *aplicativo* ) cria uma solicitação que parece muito com “Pegue essa página do site” e passe-a para a camada de apresentação. É apenas uma página da web, portanto, nada precisa ser feito aqui. A solicitação é passada para a camada de *sessão* , que no caso de páginas web é tratada por um protocolo que atua na *camada de transporte e de sessão* ao mesmo tempo: o TCP. Este protocolo identifica seu navegador e o aplicativo “site de entrega” (servidor da web) no dispositivo remoto e, em seguida, passa-o para a camada de rede. A camada de *rede* identifica onde o servidor remoto está e, em seguida, passa para a *camada de enlace de dados* , que então envia os dados para o próximo dispositivo conectado no caminho usando o dispositivo *físico*camada. Os dispositivos no caminho inspecionam seu tráfego até a camada de rede para identificar para onde ele deve ir. Ao chegar ao destino, após o servidor entender que recebeu uma solicitação especificamente para ele (camadas 1 a 3), ele entrega esse conteúdo à camada de Transporte que identifica o aplicativo local que deve responder a essa solicitação. Em suma, é assim que a Internet funciona. Só para deixar isso mais claro, temos a seguinte imagem que explica o caminho de seus dados.

![Processamento de dados em uma rede](https://www.ictshore.com/wp-content/uploads/2016/09/1005-12-Data_processing.png)Cada dispositivo processa dados até uma determinada camada da pilha OSI, dependendo de sua função na rede.

O usuário reside em cima do modelo OSI, pois é ele quem usa e controla os aplicativos. É ele quem está decidindo que quer navegar em um determinado site. Portanto, é ele quem aciona o processo digitando a URL e pressionando enter. A solicitação é processada e desce para a camada física, que a transmite em um cabo. Quando chega a um *roteador* , ele só precisa verificar para onde as informações devem ir, não se preocupando com o conteúdo, então basta abrir a caixa Data Link para inspecionar a camada de **rede** e descobrir onde as informações devem estar ir. *Switches* (outros dispositivos de rede), inspecione apenas o **link de dados**camada em vez disso. Os únicos dispositivos que lerão a camada de aplicativo são o remetente e o destinatário.

**A pilha TCP / IP** é apenas uma maneira de olhar para a rede com foco na camada de rede e transporte. Ele foi projetado dessa forma como uma abordagem em que você não se importa como coloca as informações no cabo, é apenas *“Acesso à rede”* e você não se importa com o que está inserindo são apenas *“Dados do aplicativo”* . O que você realmente importa é como esses dados chegam ao aplicativo pretendido. **O modelo híbrido** é usado como uma abordagem quando você não se preocupa com quais são os dados do aplicativo, mas se preocupa com a forma como acessa a rede.

Nos próximos artigos, abordaremos cada camada separadamente, com um ou mais artigos por camada. Agora, em vez disso, teremos uma breve seção explicando cada camada TCP / IP e sua função de maneira um pouco mais *detalhada* . Para isso, basta ler.

## Camadas de acesso à rede

Na camada de acesso à rede, encontramos a camada física e, acima dela, a camada de enlace de dados. Essas duas camadas são chamadas de “acesso à rede” da pilha TCP / IP porque conectam uma informação mais abstrata e lógica, vinda das camadas superiores, para o material físico. São eles que concedem as funcionalidades do hardware e permitem a sua utilização nas camadas superiores.

![Acesso à rede](https://www.ictshore.com/wp-content/uploads/2016/09/1005-08-Network_Access.png)O acesso à rede compreende as camadas física e de enlace de dados, conectando a camada de rede ao hardware e aos cabos.

Bem no final da pilha OSI, temos a **camada física**, que obtém informações na forma de bits e as traduz em sinais eletromagnéticos (cabos e wireless) ou pulsos de luz (fibra óptica). Essa camada não sabe nada sobre a informação, não sabe o que é a informação, por que está sendo enviada e nem mesmo quem é o destinatário pretendido, tudo isso é tratado pela camada superior. A única coisa com que nos importamos nessa camada é gerar um sinal que possa viajar por uma determinada mídia e que possa transportar o máximo de informações possível. O fato de não conhecermos o receptor nesta camada é porque confiamos na camada de enlace de dados, se a camada de enlace de dados decidir gerar um sinal em um cabo em vez de outro, a camada física apenas traduz as informações em sinais, assumindo que temos o receptor certo do outro lado.

Pelo que acabamos de dizer, entendemos que a camada física entrega informações de uma maneira estúpida para dispositivos conectados diretamente. No entanto, sem conhecer as informações em si, não é confiável e não pode descobrir se os dados foram corrompidos durante a transferência (talvez devido a algumas interferências). Precisamos de outra camada para controlar e aprimorar a camada física: a **camada de Enlace de Dados** . Esta camada controla a camada física e é dividida em duas subcamadas, chamadas *MAC (Media Access Control)* e *LLC (Logical Link Control)*. A subcamada MAC faz interface diretamente com a camada física, controlando a geração e recepção de sinais, enquanto o LLC é a parte que “encara” a Camada de Rede e recebe ordens dela. A camada de enlace de dados fornece os seguintes recursos.

- **Detecção de erros** , ele pode descobrir se a informação foi corrompida após ser transferida para um dispositivo conectado - a retransmissão não é tratada, o papel desta camada é descobrir se a informação é válida e, se não, apenas descartá-la (nem mesmo notificando o remetente)
- **Informações de endereçamento local** , ele sabe qual cabo usar para alcançar cada dispositivo *conectado diretamente*

Esses dois recursos combinados permitem o controle total da comunicação com dispositivos conectados diretamente. Neste ponto, você pode pensar que se o dispositivo / servidor / site que você está tentando acessar estiver diretamente conectado, você pode simplesmente pular todas as outras camadas e colocar a solicitação na camada de Enlace de Dados. Bem, pense novamente: o Aplicativo nunca será informado se o destino está diretamente conectado ou não, então *todas as camadas são sempre percorridas* . Mais do que isso, esta é a única maneira que o mesmo processo (Camada 7 a 1) pode ser usado independentemente da posição dos dispositivos de comunicação na Internet.

## Camadas de rede e transporte

Além do acesso à rede, temos as *camadas de rede e transporte* . Combinados, eles permitem que os aplicativos se comuniquem. Nesta seção, explicaremos de maneira um pouco mais detalhada quais são suas funções exatamente.

![Camadas de rede e transporte](https://www.ictshore.com/wp-content/uploads/2016/09/1005-09-Network_and_Transport.png)As camadas de rede e transporte estão presentes em todas as pilhas nas posições centrais.

A camada de **rede** controla diretamente a camada de enlace de dados. Ele informa a essa camada para qual dispositivo conectado diretamente as informações são enviadas, de modo que a camada de enlace de dados possa selecionar o cabo certo para alcançar aquele dispositivo. Isso é possível porque *as informações de endereçamento em toda a Internet*é processado nesta camada. A rede fornece orientação para alcançar virtualmente qualquer dispositivo na Internet e fornecer dados a ele. Porém, se os dados se perderem no caminho (a camada de Enlace descarta uma “caixa” porque detectou algumas interferências que corromperam os dados), a camada de rede não é notificada e os dados são perdidos. A retransmissão deve ser tratada pelas camadas superiores. Essa camada funciona muito como uma agência postal: ela processa endereços, cada endereço contendo todas as informações necessárias para chegar ao destinatário. Para cada caixa recebida, olhamos para o país. Se for para outro país, enviamos para uma agência dos correios do outro país, porque não sabemos (nem podemos) chegar ao endereço especificado. A outra estação enviará a caixa para a cidade certa, onde o carteiro a entregará no destinatário.Isso é exatamente o que a camada de rede faz.

Assim que a caixa chegar ao prédio certo, o trabalho do carteiro está concluído. Agora é a hora de outra pessoa entregar todas as caixas recebidas em um prédio para a pessoa certa. Esse é o trabalho da camada de **transporte** , que pega os dados da camada de rede e, com seu próprio sistema de endereçamento, os *entrega ao aplicativo certo* . Os endereços dos aplicativos são exclusivos no mesmo computador, enquanto os endereços de rede são exclusivos na Internet (isso não é totalmente verdade, mas por agora pense que é). Uma combinação de endereços da camada de transporte e da camada de rede é chamada de soquete e identifica uma conexão única na Internet.

O protocolo utilizado atualmente na camada de rede é o **IP (Internet Protocol)** , embora utilizemos principalmente dois protocolos de transporte: **TCP (Transmission Control Protocol)** e **UDP (User Datagram Protocol)** .

## Camada de aplicação

A camada de aplicação reside *no topo* de todas as pilhas, com o modelo TCP / IP e híbrido, incluindo também as camadas de apresentação e sessão. Isso se deve ao fato de que muitas vezes a apresentação de tempo e as tarefas relacionadas à sessão são gerenciadas pelo próprio aplicativo. Apenas para estar na mesma página, um aplicativo é um navegador da web, um servidor da web, um jogo online, um aplicativo em um smartphone que mostra conteúdo online e assim por diante.

![Camada de aplicação](https://www.ictshore.com/wp-content/uploads/2016/09/1005-10-Application.png)A camada de aplicação TCP / IP compreende as camadas de Sessão, Apresentação e Aplicação da pilha OSI.

Vindo da camada de transporte, a primeira camada que encontramos é a camada de **sessão** . Sua principal tarefa é garantir que os dados cheguem ao destino recuado (aplicativo). Ou seja, implementa alguns mecanismos que permitem a retransmissão dos dados caso algo se perca. Caso não nos importemos em recuperar o que foi perdido, mas queremos saber se algo foi perdido, esta funcionalidade é sempre tratada nesta camada. O TCP é um protocolo de transporte que lida com retransmissões, portanto, atua também na camada de sessão. UDP não tem mecanismo para recuperar dados perdidos no caminho (é considerado não confiável), então se quisermos usar UDP, mas queremos saber se algo se perde, podemos usar RTP ( *Real-Time Protocol)*na camada de sessão. Este protocolo é comumente usado para streaming de tráfego, porque o streaming é em tempo real por natureza e precisa ser rápido, não temos tempo para retransmissões. Esses conceitos serão explicados com muito mais detalhes em um artigo dedicado ao longo do curso CCNA.

A próxima camada que encontramos é a **Apresentação**camada, que é responsável por lidar com a forma como os dados são apresentados à aplicação. É raro encontrar protocolos que funcionem apenas nesta camada, porque na maior parte do tempo eles são implementados no próprio aplicativo. Obviamente, se for implementado na camada do aplicativo, os programadores que desenvolveram o aplicativo apresentam os dados ao próprio aplicativo da maneira que desejam, para que o aplicativo possa processá-los facilmente. Um caso em que vemos a camada de apresentação como autônoma é para o tráfego VoIP. Para VoIP, antes que a chamada seja feita (estabelecida), um codec é negociado. Um codec é uma forma de compactar áudio (e / ou vídeo) que influencia a qualidade do stream, o desempenho em termos de largura de banda (quanta velocidade de internet é necessária) e poder computacional (quanta potência seu PC precisa ter para produzir você ouve aquele áudio).Diferentes codecs são usados dependendo das necessidades, alguns podem precisar da melhor qualidade, outros terão que sacrificá-la devido aos limites de velocidade da internet.

Por fim, temos a camada de **aplicativo** . Não podemos dizer nada específico sobre esta camada, simplesmente porque cada aplicação é diferente e define seu (s) próprio (s) protocolo (s). No entanto, muitos aplicativos são padrão, como a web, que nada mais é do que tráfego **HTTP (Hyper-Text Transport Protocol)** . HTTP é o protocolo usado para navegar em páginas da web, você digita URLs começando com *`http://`*. Outro protocolo é o *HTTPS* , que é a versão segura do HTTP: os dados podem ser somente leitura *do* remetente e do destinatário. Existem muitos protocolos trabalhando nesta camada, como *SMTP, POP3* e *IMAP* para e-mails. Podemos listar toneladas de protocolos diferentes, mas isso está fora do escopo deste artigo.

Ok, este artigo estava *repleto de novos conceitos* , então fique à vontade para *dedicar* algum tempo para entendê-los verdadeiramente. O que aprendemos será uma base sólida para desenvolver habilidades de rede poderosas. Pode parecer um pouco complexo se você for completamente novo em rede, mas quanto mais você se aprofunda, mais tudo fica mais claro. Você deve ter adivinhado, os próximos artigos da série (curso CCNA) abordarão cada camada individual da pilha OSI de uma maneira muito detalhada. Antes de fazer isso, encontraremos outro artigo para explicar a *matemática binária* , a base das TIC.