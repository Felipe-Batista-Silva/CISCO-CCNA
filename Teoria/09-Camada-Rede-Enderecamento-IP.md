# Camada de rede: endereçamento IPv4 e protocolo IPv4



IPv4, simplesmente conhecido como IP, é o protocolo rei no mundo das redes. É aquele usado para entregar informações em qualquer lugar na Internet, do Havaí à Sibéria, da China à Escócia. Em nosso mundo globalizado, você precisa falar inglês, não importa de onde você seja. No mundo da Internet, você precisa falar IP, não importa de onde você seja. Neste artigo, exploraremos a estrutura e as funcionalidades deste protocolo, entendendo suas características e benefícios que o tornam o rei da colina, aquele que faz a Internet funcionar, em todo o mundo. Com isso, aprenderemos o endereçamento IPv4, introduzindo os conhecimentos necessários para planejar e projetar uma rede.

*Observação: para entender totalmente este artigo, você deve ter um conhecimento básico da pilha OSI e de suas camadas inferiores (física e enlace de dados). Caso você não esteja familiarizado com eles, verifique os artigos do nosso curso CCNA - que também inclui este artigo! -, você encontrará todas as informações de que precisa.*

## Noções básicas de endereçamento IPv4: endereços e sub-redes

Já introduzimos o conceito de endereços quando [explicamos a camada de enlace de dados no artigo anterior](https://www-ictshore-com.translate.goog/free-ccna-course/data-link-layer/?_x_tr_sl=en&_x_tr_tl=pt&_x_tr_hl=nl&_x_tr_pto=nui) , e o conceito é semelhante em alguns aspectos e diferente em outros. Um endereço de camada de enlace de dados é conhecido apenas entre dispositivos contíguos (dispositivos no mesmo domínio de broadcast), enquanto um endereço de rede também é conhecido fora do domínio de broadcast e potencialmente globalmente. Esteja ciente de que qualquer dispositivo terá um endereço em todas as camadas, portanto, terá um endereço da camada de enlace e um endereço da camada de rede, sendo o primeiro físico e o segundo **lógico** . Este endereço de camada de rede é lógico porque *não está embutido no dispositivo* como um endereço MAC, mas em vez disso, *é atribuído*para o dispositivo. Pode ser configurado pelo administrador, ou pode ser obtido automaticamente, dependendo da infraestrutura.



Podemos comparar um endereço da camada de rede a um **endereço global**você escreve em um cartão-postal ou em uma carta. Você vai escrever o país, a cidade, o código postal, a rua e o número cívico em seu envelope. Todas essas informações combinadas criam o próprio endereço, que depende estritamente do local: dois países diferentes terão endereços diferentes. Se você mudar de um país para outro, terá um endereço diferente e, se um dispositivo se mudar de uma parte da rede para outra, terá um endereço diferente. Normalmente, escrevemos endereços em um envelope a partir das informações mais específicas (como o nome da pessoa para quem estamos escrevendo) e adicionamos nas linhas seguintes informações mais genéricas (a rua, a cidade, o país). No entanto, isso é contra-intuitivo, faz muito mais sentido ir*desde as informações mais genéricas até as mais específicas* . Isso é o que fazemos na rede: se aplicássemos o mesmo conceito ao nosso sistema de mala direta, ele se pareceria muito com a imagem a seguir.

![Endereçamento geográfico](https://www.ictshore.com/wp-content/uploads/2016/11/1013-01-Geographical_address.png)Usamos endereços em correio tradicional para restringir o escopo da entrega da carta. O networking funciona exatamente da mesma forma, indo do genérico para o cada vez mais específico.

No correio tradicional, desenvolvemos um *sistema de endereçamento geográfico* para facilitar a troca de cartas. Pelo mesmo motivo, tentamos aplicar uma abordagem semelhante à rede. Essa ideia não foi aplicada a 100% com o IPv4 por *razões práticas* , então dois dispositivos geograficamente distantes não terão endereços semelhantes em geral, mas pode acontecer de vez em quando. Em vez de realizar um sistema de endereçamento geográfico perfeito, criamos um **sistema de endereçamento lógico** perfeito : as redes são divididas não por posição geográfica na maioria das vezes, mas por causa de seus recursos lógicos e funções na rede global. Pensando nisso, estamos prontos para enfrentar o *que é o IPv4* .

**IPv4** ( *expandido para IP versão quatro* ) é a quarta versão do IP, que significa **Internet Protocol** , e por ser a versão mais usada no momento, é simplesmente conhecido como IP. É um protocolo gratuito e, devido aos seus recursos e flexibilidade, substituiu gradualmente todos os protocolos proprietários legados que operavam na camada de rede, como AppleTalk, IPX ou Xerox Network Systems (XNS). O IPv4 está descrito detalhadamente no [RFC 791](https://translate.google.com/website?sl=en&tl=pt&nui=1&u=https://tools.ietf.org/html/rfc791) , um documento online que destaca todas as especificidades deste protocolo para que caso esteja a criar um novo dispositivo ou software que deva funcionar com IPv4 saiba como funciona. O IPv4 vem de um conjunto de estudos de redes de comutação de pacotes iniciado em 1974 e foi oficialmente lançado em 1978.

Como qualquer protocolo de rede, o IPv4 funciona com dois elementos principais: *informações enviadas* junto com os dados para outros dispositivos e *endereços* . Basicamente, cada dispositivo possui um endereço atribuído (ou vários endereços em casos especiais), assim como cada residência possui um endereço. Os dados provenientes das camadas superiores são colocados em um envelope virtual com um endereço IP de origem e de destino escrito nele. Os dispositivos intermediários verificarão esse envelope para enviar essa informação, tecnicamente conhecida como *Unidade de Dados de Protocolo (PDU)* , para o dispositivo de destino correto. Uma PDU de camada de rede é conhecida como **Pacote** .

Antes de explicar a estrutura de um pacote IP, devemos explicar como os endereços IP são feitos e como funcionam. Um endereço IPv4 tem *4 bytes de comprimento* (32 bits). Para representá-lo de uma forma mais legível, convertemos *cada byte em* notação *decimal* e escrevemos assim, dividindo o valor decimal de cada byte do próximo com um ponto. Isso é conhecido como **notação de ponto** IPe, na verdade, é a única maneira aceita de escrever um endereço IP. Assim como qualquer endereço em qualquer nível, lembre-se de que representá-lo em notação decimal serve apenas para torná-lo legível: os computadores sempre armazenam e processam endereços em bits. Dado isso, os bits à esquerda são mais genéricos do que os bits à direita: isso significa que os bits à esquerda correspondem ao país em um endereço postal, enquanto os da direita correspondem ao número cívico. Da esquerda para a direita, vamos *do genérico ao específico* .

![endereço de IP](https://www.ictshore.com/wp-content/uploads/2016/11/1013-02-IP_address.png)Um endereço IPv4 é uma string de quatro bytes representada em notação pontilhada.

As casas contíguas têm quase o mesmo endereço, só o número cívico é que muda entre uma e outra. O mesmo conceito se aplica a dispositivos de rede e endereços IP. Ao contrário dos endereços MAC, que são independentes da localização do dispositivo, os endereços IP de dispositivos contíguos terão a primeira parte igual e *os bits à direita mudando de um dispositivo para outro* , assim como os números cívicos.

![Mapeamento de sub-rede para transmissão de domínio](https://www.ictshore.com/wp-content/uploads/2016/11/1013-03-Subnet_to_broadcast_domains.png)Assim como as casas na mesma rua, os computadores no mesmo domínio de broadcast (sub-rede) terão a maior parte do endereço IP em comum e apenas alguns bits à direita mudam de um para o outro.

A partir disso, podemos entender que a primeira parte de um endereço IP pode ser comparada à combinação de país, código postal e rua em um endereço postal. A última parte à direita, em vez disso, pode ser comparada ao número cívico. Em termos de rede, a primeira parte é conhecida como **ID de rede** e a última parte (o “número cívico”) é conhecida como **ID de host** , onde com “host” queremos dizer dispositivo. Com “rede”, neste caso, queremos dizer a sub-rede, que é um grupo de dispositivos contíguos que compartilham o mesmo domínio de broadcast. Em outras palavras, o que é uma **sub** - **rede** na camada de rede é um *domínio de broadcast* na camada de enlace de dados e vice-versa.

![Rede e host](https://www.ictshore.com/wp-content/uploads/2016/11/1013-04-Network_and_host.png)A primeira parte de um endereço IP identifica a rede ou sub-rede, a segunda parte identifica o dispositivo dentro dessa sub-rede. Nesse caso, a divisão ocorre logo após o terceiro byte, mas pode acontecer em qualquer ponto do endereço IP.

## Endereçamento com e sem classe

A próxima pergunta é quase automática: como podemos identificar as partes do ID da rede e do ID do host em um endereço IP? É extremamente importante saber onde termina uma parte e onde começa a outra. Originalmente, usamos uma técnica chamada **endereçamento classful** , que define o tamanho da parte do ID da rede com base nos primeiros bits nos endereços IP. Com base nos primeiros bits do endereço IP, dividimos os endereços IP em *cinco classes* (de A a E). Os endereços nas classes A, B e C são endereços “normais” que podem ser atribuídos a dispositivos. Os endereços na classe D são endereços *multicast* especiais , usados para alcançar vários dispositivos, enquanto a classe E é usada para endereços *experimentais* . Se o primeiro bit for`0`, então o endereço é um endereço de classe A, com a parte da rede terminando no oitavo bit. Se os primeiros bits forem `10`, então temos uma classe B, se forem `110`, temos uma classe C e assim por diante. Dê uma olhada na imagem a seguir, representando todas as classes.

![Endereçamento classful](https://www.ictshore.com/wp-content/uploads/2016/11/1013-05-Classful_addressing.png)O método legado para identificar o tamanho da parte da rede e da parte do host era baseado nos primeiros bits do endereço IP e usava seus valores para dividir os endereços IP em cinco classes.

Quanto mais bits tivermos na porção de ID de rede, mais redes diferentes poderemos ter. Por outro lado, quanto mais a parte do ID da rede cresce, menor fica a parte do ID do host. Por causa disso, teremos alguns IDs de rede na classe A, com muitos hosts em cada um deles. Na classe C, em vez disso, teremos muito mais IDs de rede, mas com menos hosts em cada rede. A tabela a seguir destaca exatamente isso.

| Classe | Faixa                              | Espaço de Rede | Espaço Host | Redes Disponíveis | Hosts Disponíveis |
| ------ | ---------------------------------- | -------------- | ----------- | ----------------- | ----------------- |
| UMA    | `1.0.0.0` para `27.255.255.255`    | 7 bits         | 24 bits     | 128               | 16.777.216        |
| B      | `128.0.0.0` para `191.255.255.255` | 14 bits        | 16 bits     | 16.384            | 65.536            |
| C      | `192.0.0.0` para `233.255.255.255` | 21 bits        | 8 bits      | 2.097.152         | 256               |
| D      | `224.0.0.0` para `239.255.255.255` | -              | -           | -                 | -                 |
| E      | `240.0.0.0` para `255.255.255.254` | -              | -           | -                 | -                 |

Classes de endereço

O endereçamento com classe é uma solução e funciona, mas nem sempre é tão prático. Digamos que você tenha uma rede onde planeja conectar no máximo 10 dispositivos, você deve usar uma rede de classe C com espaço para até 256 hosts. O espaço restante (246 hosts) é desperdiçado porque você não vai usá-lo, mas como você o comprou, ninguém mais poderá usá-lo. Se você precisa conectar 257 hosts, vai precisar de uma rede classe B, que comporta 65 mil dispositivos, desperdiçando ainda mais espaço. No total, temos *4'294'967'296 endereços IPv4 possíveis* em todo o mundo (32 bits, 2 32é igual a 4 bilhões). Quatro bilhões de endereços podem parecer muito, mesmo se removermos os endereços multicast e os endereços experimentais ainda temos um grande número de hosts, mas não importa o quão grande seja, não será o suficiente. Temos mais dispositivos conectados à Internet que é difícil fazê-los funcionar com apenas quatro bilhões de endereços, então nenhum desperdício é aceitável aqui. Para aumentar a *flexibilidade* e atender a essa necessidade, o **endereçamento classless** foi lançado. Neste caso, o tamanho da porção do ID de rede não é determinado pelo primeiro bit do endereço IP, mas em vez de um elemento complementar do endereço IP, a **máscara de sub-rede**. A máscara de sub-rede é outro campo de 32 bits que informa onde termina a parte do ID da rede. Enquanto em um endereço IP você pode ter qualquer combinação de bits que desejar, em uma máscara de sub-rede `1`pode ser seguido por outro `1`ou um `0`, enquanto um `0`pode ser seguido apenas por outro `0`. Dessa forma, você acabará com todos `1`à esquerda e todos `0`à direita. Então, você combina o endereço IP com a máscara de sub-rede: onde a máscara de sub-rede está `1`, o respectivo bit no endereço IP será contado como parte do ID da rede, onde a máscara de sub-rede está `0`, o respectivo bit no endereço IP será contado como parte da ID do host.

![Endereçamento sem classes](https://www.ictshore.com/wp-content/uploads/2016/11/1013-06-Classless_addressing.png)Com o endereçamento classless, a máscara de sub-rede define onde termina o ID da rede.

Todas as redes modernas funcionam com endereçamento classless, por isso não ficamos sem endereços IPv4 nos anos 90. No entanto, esteja ciente de que *a máscara de sub-rede nunca é enviada em um pacote IP* . Em vez disso, é um valor armazenado em cada PC: cada dispositivo conhecerá sua máscara de sub-rede, então, quando quiser enviar um pacote para qualquer IP, ele comparará esse IP de destino com a combinação de seu próprio IP e máscara de sub-rede para ver se esse destino faz parte da sua sub-rede ou não. Em seguida, o pacote sairá do dispositivo com origem e destino especificados, mas sem máscaras de sub-rede.

Sabemos que a maioria dos endereços IP são unicast e aqueles de 224.0.0.o a 239.255.255.255 endereços multicast. Que tal **transmitir** então? Assim como na camada de enlace de dados, também temos endereços de broadcast na camada de rede. Mais do que isso, com o IPv4 temos dois tipos de endereços de broadcast: broadcast padrão e broadcast direcionado.

O endereço de **broadcast padrão** é `255.255.255.255`e representa todos os nós na mesma sub-rede, não importa qual sub-rede. Corresponde perfeitamente ao endereço da camada de enlace `FF:FF:FF:FF:FF:FF`, mais do que isso: um pacote destinado a um broadcast de rede padrão será colocado em um quadro com esse endereço MAC de broadcast como destino. Observe que se escrevermos esse tipo de endereço de broadcast em binário, isso resultará em todos `1`.

O outro tipo de transmissão para IPv4 é chamado de **transmissão direcionada** e é aquele a ser usado se você deseja alcançar todos os nós em uma sub-rede específica (que não é a sua sub-rede). Nesse caso, não há um único endereço de broadcast específico, esse endereço deve ser calculado. Para fazer isso, você deve identificar a parte do ID do host do seu endereço e colocar todos os seus bits em 1, dessa forma você obterá o endereço de broadcast direcionado para a sua sub-rede. Por exemplo, se você trabalha com uma sub-rede `10.1.1.0`e uma máscara de `255.255.255.0`, você sabe que o último byte é a parte do ID do host, então o endereço de transmissão direcionado será`10.1.1.255`. Assim que o pacote com esse destino atingir a sub-rede de destino, ele será convertido em um broadcast padrão. É importante mencionar que os únicos que sabem que este endereço é um endereço de broadcast direcionado são o dispositivo de origem e os dispositivos na sub-rede de destino. O dispositivo de origem deve saber disso porque está gerando tráfego para aquele destino por uma razão (pelo menos esperamos que seja!), Enquanto os dispositivos na sub-rede de destino sabem disso porque *podem combiná-lo com sua máscara de sub-rede* e descobrir que isso é transmitido. Todos os outros dispositivos intermediários no caminho entre a origem e o destino não têm a máscara de sub-rede do destino e não podem distingui-la de um endereço unicast normal. No entanto, esse tipo de tráfego geralmente é *bloqueado*do dispositivo de borda da rede de destino (o dispositivo que conecta essa rede ao mundo externo), porque pode ser malicioso. Se, por algum motivo, precisarmos desse tráfego, devemos habilitá-lo em nosso dispositivo de borda.

## O Pacote IP

Como devemos saber, a cada camada OSI que a informação atravessa descendo, algumas informações extras são adicionadas. A camada de rede não faz exceção e o IP tem seu próprio **pacote** . Principalmente, é usado para definir os endereços IP de *origem e destino* , mas faz mais do que isso. Vamos dar uma olhada no pacote.

![Pacote IP](https://www.ictshore.com/wp-content/uploads/2016/11/1013-07-IP_Packet.png)Um pacote IP é enviado para fornecer informações a dispositivos remotos.

Como entendemos na imagem, o **pacote IPv4** não é simplesmente sobre os endereços IP de origem e destino. Em vez disso, algumas informações extras completam a cena. Como qualquer PDU, há um cabeçalho e um corpo / conteúdo. As informações são adicionadas na parte do cabeçalho, enquanto o corpo é apenas o conteúdo proveniente das camadas superiores. Vamos explicar qual é a função de cada campo no cabeçalho.

- **Versão** - indica a versão do protocolo IP e é sempre definido como 4 para IPv4

- **Comprimento do cabeçalho da Internet (IHL)** - Especifique o tamanho do cabeçalho do pacote IP, pois pode variar dependendo das opções adicionadas

- **Ponto de código de serviços diferenciados (DSCP)** - Usado em novas tecnologias que requerem streaming em tempo real, como VoIP

- **Notificação explícita de congestionamento (ECN)** - Este campo permite que os dois dispositivos que se comunicam notifiquem um ao outro sobre o congestionamento da rede antes que tenham que descartar os pacotes

- **Comprimento total** - o comprimento total do pacote IP, incluindo dados, em bytes

- **Identificação** - Este campo é usado para identificar pacotes IP do mesmo fluxo

- Sinalizadores

   \- campo de três bits, composto por três sinalizadores diferentes, conforme explicado a seguir

  - Reservado para uso futuro, deve ser definido como 0
  - **DF (Don't Fragment)** - este pacote não pode ser dividido em vários pacotes menores, caso o pacote tenha que passar por uma mídia / link que suporte apenas pacotes menores, ele será descartado
  - **MF (More Fragments)** - defina como 1 se este pacote for o resultado de fragmentação e outro fragmento vier após este

- **Deslocamento de fragmento** - caso o pacote esteja fragmentado, informa qual byte do pacote original não fragmentado corresponde ao primeiro byte deste pacote, em um pacote não fragmentado ou no primeiro dos fragmentos é 0, pois o primeiro byte do pacote atual corresponde ao primeiro byte do pacote original, então não há deslocamento

- **Time to Live (TTL)** - Campo usado para evitar loops, cada vez que o pacote passa por um dispositivo de rede, este campo é diminuído em um quando um dispositivo recebe um pacote com TTL 0, ele o descarta para que o pacote tenha um máximo número de saltos que pode percorrer antes de cair

- **Protocolo** - Identificador do protocolo da camada 4 encapsulado no pacote atual

- **Soma de verificação do cabeçalho** - um "resumo" lógico do cabeçalho, usado a partir de dispositivos intermediários para verificar se as informações do cabeçalho IP não foram interrompidas durante a transmissão

- **Endereço de origem** - **endereço** IP do dispositivo de origem

- **Endereço de destino** - **endereço** IP do dispositivo de destino

- **Opções** - raramente usadas, o cabeçalho do pacote IP pode ser estendido com alguns campos extras; cada opção pode ser considerada como um registro que possui vários campos: copiado (se a opção tiver que ser copiada em todos os fragmentos), classe (categoria), número (identificador específico para a opção), comprimento e dados da opção, no caso da opção campo é muito pequeno ele é preenchido com zeros extras à direita para atingir o comprimento padrão, esse espaço de zero extra é chamado de **preenchimento**

- **Dados** - Conteúdo proveniente de camadas superiores

Agora que sabemos como um pacote IP é feito, podemos entender como ele é movido pela rede. É hora de falar sobre o roteador.

## O roteador

O **roteador** é o dispositivo da camada de rede mais famoso. Sua função é simples, mas fundamental, encaminhar o tráfego para o destino correto com base nas informações da camada de rede. Essa operação é conhecida como *“roteamento de tráfego”* ou simplesmente *“roteamento”* . Para que um roteador seja útil, ele deve ter pelo menos duas placas de interface de rede, cada uma com seu próprio endereço MAC e IP: cada interface deve ser colocada em uma sub-rede diferente. Na verdade, existe apenas um único tipo de roteador com apenas duas interfaces, e é o **Integrated Service Router (ISR)** . É *um aparelho multifuncional de baixo custo*, aquele que você tem em casa que o seu provedor de internet lhe deu. Este é um caso especial porque basta enviar tudo que vem de você para a Internet e tudo que se destina a você que vem da Internet para você. Todos os roteadores usados em um ambiente Internet ou Enterprise terão *pelo menos três interfaces* para fazer algum tipo de roteamento “real”.

Basicamente, um roteador recebe um pacote e verifica o destino escrito nesse pacote em relação a todos os destinos que ele conhece e, em seguida, encaminha o pacote *"como está"* para fora da interface correta. Mais do que isso, o roteador **descarta o quadro de link de dados em** que o pacote de entrada foi encapsulado e o envia com um novo quadro. Isso ocorre porque o quadro de link de dados é significativo apenas no mesmo domínio de broadcast e porque um roteador pode ter interfaces de tipos diferentes (um quadro proveniente de uma interface Ethernet pode sair de uma interface de fibra óptica).

![O roteador](https://www.ictshore.com/wp-content/uploads/2016/11/1013-08-The_Router.png)Um roteador encaminha informações para a sub-rede remota correta com base nas informações (endereço de destino) contidas nos pacotes IP que recebe.

O roteador não se limita a rotear pacotes que chegam e vão para sub-redes conectadas, ele também pode armazenar informações sobre sub-redes remotas (não conectadas diretamente). Este tipo de informação é armazenada assim: *Para chegar a esse sub-X, devo passar por sub-Y* . Dessa forma, todo o tráfego destinado à sub-rede X será enviado para fora da interface da sub-rede Y. Esse processo é feito por todos os roteadores no caminho até que o pacote chegue ao destino. As informações necessárias para o roteador alcançar uma sub-rede específica são chamadas de **rota** , e as rotas são todas armazenadas na chamada **tabela de roteamento** , com a lista de todos os destinos disponíveis.

Um tipo interessante de roteador é o **roteador padrão**. Não se trata do que ele é, é apenas um roteador normal, trata-se do que ele faz. Um roteador padrão é o roteador por meio do qual todos os dispositivos em uma sub-rede podem alcançar todo o resto. Os dispositivos sabem que todo o resto da Internet estará acessível por meio desse roteador, portanto, todo o tráfego que não for para a sub-rede local será enviado a ele. Os dispositivos de origem são inteligentes o suficiente para saber se um destino está em sua sub-rede local ou não. Caso não seja, eles sabem que, para acessá-lo, devem enviá-lo ao seu roteador padrão. Por causa disso, eles criarão o pacote IP para o destino correto, mas o colocarão em um quadro de link de dados destinado ao endereço MAC do roteador padrão, para que possa acessá-lo imediatamente. Então,o roteador padrão verificará o IP de destino em relação à sua tabela de roteamento e o enviará à direita ao lado do roteador no caminho. O roteador padrão também é conhecido como o**gateway padrão** , enquanto os roteadores em qualquer caminho são conhecidos como **saltos** .

![Roteador padrão](https://www.ictshore.com/wp-content/uploads/2016/11/1013-09-Default_router.png)O roteador padrão é aquele que fornece acesso à Internet a uma sub-rede, todos os dispositivos dessa sub-rede saberão que precisam usá-lo para acessar todo o resto.

Agora que sabemos como o tráfego é roteado na Internet, uma única parte está faltando na imagem: o pacote IP deve ser colocado dentro de um quadro de link de dados para ser enviado a um endereço MAC de destino. Como podemos saber o endereço MAC de destino, já que ele não está relacionado à nossa sub-rede, mas sim ao fornecedor do hardware da placa de rede do dispositivo de destino? Vamos descobrir isso na próxima seção.

## ARP

ARP significa **Address Resolution Protocol** e é um protocolo da camada de enlace que cria uma ligação entre endereços MAC e endereços IP. Este protocolo é usado para obter o endereço MAC de um dispositivo em seu domínio de broadcast, se você já souber seu endereço IP. Este protocolo é dramaticamente simples, mas eficaz, o princípio é este: nós apenas pedimos. Sim, o dispositivo que conhece o IP, mas não o endereço MAC do destino, usa o ARP para perguntar *“Quem tem esse endereço IP? Você poderia me dizer seu endereço MAC, por favor? ”* . Isso é conhecido como **solicitação ARP** e, se for bem-sucedido, um dispositivo na mesma sub-rede irá gerar uma **resposta ARP** , ou *resposta ARP* , para informar ao outro dispositivo *“Ei, sou eu!”* .

Como ainda não sabemos o endereço MAC de destino, a *solicitação ARP* é enviada dentro de um quadro de transmissão de link de dados. Os principais elementos contidos nesta solicitação são o endereço IP que procuramos e nosso próprio endereço MAC. Enviamos nosso próprio endereço MAC para permitir que um dispositivo, por outro lado, responda. Você pode pensar que enviar nosso endereço MAC não é necessário porque o dispositivo de destino já o conhece do envelope da camada de enlace, mas isso não é necessariamente verdade. Nem todos os dispositivos aprendem os endereços MAC dos quadros recebidos, apenas os switches. Mais do que isso, o envelope de link de dados é descartado no nível da NIC no dispositivo de destino, de forma que o processo que gerencia o ARP nem o lê. Então, apenas para agilizar o processo, enviamos nosso endereço MAC na solicitação.

![Pedido ARP](https://www.ictshore.com/wp-content/uploads/2016/11/1013-10-ARP_request.png)Com uma solicitação ARP enviada a todos os nós contíguos, um PC pergunta se um deles é o dispositivo de destino que está procurando.

Como o dispositivo de destino já conhece nosso endereço MAC, ele nos responderá diretamente em unicast na camada de enlace de dados, escrevendo seu próprio endereço MAC dentro da mensagem *ARP Reply* . Assim que tivermos isso, podemos *estabelecer comunicação* com ele. Cada vez que um processo de solicitação-resposta ARP termina com sucesso (ou seja, quando o dispositivo de destino responde), atualizamos uma tabela armazenada em nosso dispositivo que mantém a ligação entre endereços IP e endereços MAC. Essa tabela é conhecida como **tabela ARP** ou *cache ARP* e cada registro que adicionarmos será *eliminado*em algum tempo (geralmente dez minutos) se não recebermos mais tráfego dele. Se dentro desses 10 minutos recebermos um quadro com aquele endereço MAC carregando um pacote com aquele IP, o cronômetro é redefinido para 10 minutos.

![Resposta ARP](https://www.ictshore.com/wp-content/uploads/2016/11/1013-11-ARP_response.png)Com uma Resposta ARP, o dispositivo correto entre aquele contatado anteriormente com a Solicitação ARP responderá diretamente ao dispositivo que originou a Solicitação ARP, informando o seu endereço MAC.

Pode valer a pena gastar algum tempo conversando sobre o processo ARP quando quisermos nos comunicar com um *host remoto* , um dispositivo que não está em nosso domínio de broadcast. Para fazer isso, sabemos que temos que passar por nosso gateway padrão, mas assim que ligarmos nosso dispositivo, a tabela ARP estará vazia, então precisamos fazer algumas solicitações ARP para nos comunicarmos. Nosso dispositivo é muito inteligente, então, quando perceber que enviará um pacote a um dispositivo remoto, ele tentará colocá-lo em um quadro destinado ao endereço MAC do roteador padrão. Se esse endereço MAC for desconhecido, ele fará uma solicitação ARP, perguntando *quem tem o IP do gateway*, não quem tem o IP remoto. O gateway padrão responderá com seu endereço MAC, então o pacote para o destino remoto será enviado dentro de um quadro destinado ao gateway padrão. Caso nosso dispositivo de origem não seja tão inteligente ou provavelmente tenha uma configuração errada, ele pode solicitar o endereço MAC do destino remoto. O problema, nesse caso, é que o destino remoto não ouvirá essa solicitação porque não está no mesmo domínio de broadcast, mas há um recurso implementado em roteadores que pode ajudar. É o **proxy ARP**, que pode ser ligado ou desligado de acordo com nossa vontade. Sua funcionalidade é direta, o roteador escuta as solicitações ARP e responde com seu próprio endereço MAC se essa solicitação solicitar seu próprio IP ou um IP que o roteador sabe que pode alcançar (mesmo por meio de outras sub-redes). Isso deve ser evitado porque a tabela ARP pode obter muitos registros (você não terá apenas um registro para o seu gateway, mas para todos os destinos remotos que você tentar contatar), podendo apresentar algum atraso ou comportamento inesperado.

![ARP e roteador padrão](https://www.ictshore.com/wp-content/uploads/2016/11/1013-12-ARP_and_default.png)Ao falar com um destino remoto, a solicitação ARP é feita para o roteador padrão, não para o destino remoto.

O Address Resolution Protocol é uma grande invenção porque permite que a comunicação seja estabelecida de forma dinâmica, sem a necessidade de configurar manualmente a associação entre endereços IP e endereços MAC. No entanto, este é o único objetivo do ARP e, sem as devidas *precauções* , pode levar a sérias **exposições de segurança**. Ao fazer uma solicitação ARP, você ainda não sabe o endereço MAC de destino, portanto, estará pronto para aceitar basicamente tudo. Mais do que isso, você exceto apenas uma única resposta ARP, porque o dispositivo de destino deve ser apenas um, então, assim que você o receber, preencherá sua tabela ARP. Um hacker pode enviar uma resposta ARP mal-intencionada antes que o dispositivo legítimo tenha a chance de fazê-lo, então você pensará que está falando com o dispositivo de destino correto, enquanto se dirige ao hacker. Esse ataque é conhecido como **falsificação de ARP** porque o dispositivo do hacker se faz passar por outro dispositivo usando seu endereço MAC. Alguns dispositivos antigos também podem ser vulneráveis a **ARP gratuito** ou *ARP não solicitado*: isso é exatamente o que o nome sugere, respostas ARP enviadas sem serem solicitadas. Embora a ideia não seja maliciosa e tenha sido concebida para permitir que os dispositivos facilitem a manutenção das tabelas ARP uns dos outros sem que algumas entradas sejam eliminadas, este é um problema de segurança dramaticamente grande porque com o comportamento ARP normal, o hacker deve esperar que você faça uma solicitação ARP e seja mais rápido do que qualquer outro dispositivo. Em vez disso, com o ARP gratuito, ele pode apenas se conectar à rede, enviar uma resposta e substituir seus registros de cache ARP. Felizmente, quase nenhum dispositivo moderno é configurado para aceitar ARP gratuito, e ARP spoofing pode ser negado com alguma configuração em um switch, que veremos mais tarde no Curso CCNA.

![ARP Spoofing](https://www.ictshore.com/wp-content/uploads/2016/11/1013-13-ARP_spoofing.png)Com ARP spoofing, um hacker (canto inferior direito) pode mentir sobre sua identidade e se passar por outro dispositivo usando uma resposta ARP criada.

Com este artigo, cobrimos as funcionalidades do *Protocolo de Internet versão 4* , o que hoje é usado para permitir a comunicação entre dispositivos remotos em todo o mundo. Com esse conhecimento, agora estamos prontos para mergulhar no mundo das sub-redes, aprender sobre os diferentes tipos de endereços IP (públicos e privados) e começar a entender um plano de endereçamento.